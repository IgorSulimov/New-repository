using namespace std;
#include <iostream>
struct EL_TS
{
	int label; // значение метки
	int ind_TL; // номер в таблице лексем
	int next; // альтератива
};
class Hash
{
	int n_max; // максимальная размерность таблицы
	int n_os; // текущая размерность
	int NTS = 101; // первая свободная запись в таблице строк
	EL_TS* t;

	int Hash_function(int key)
	{
		return (key % n_os) + 1;
	}

public:
	Hash(int n1 = 50, int os = 10)
	{
		n_max = n1;
		n_os = os;
		NTS = os + 1;
		t = new EL_TS[n_max];
		for (int i = 0; i < n_max; i++)
		{
			t[i].label = t[i].ind_TL = -1;
			t[i].next = 0;
		}

	}
	Hash(Hash& other)
	{
		n_max = other.n_max;
		n_os = other.n_os;
		NTS = other.NTS;

		for (int i = 0; i < n_max; i++)
		{
			t[i].next = other.t[i].next;
			t[i].label = other.t[i].label;
			t[i].ind_TL = other.t[i].ind_TL;
		}
	}
	int find(int key)
	{
		int i = Hash_function(key);
		if (t[i].label == key)
			return i;
		while (t[i].next != 0)
		{
			i = t[i].next;
			if (t[i].label == key)
				return i;
		}
		return -1;
	}
	void add_el(int key)
	{
		int i = Hash_function(key);
		int fl = 0;
		if (t[i].label == -1)
		{
			t[i].label = key;
			t[i].ind_TL = i;
			t[i].next = 0;
		}
		else
		{
			int k = t[0].ind_TL;
			EL_TS* tmp = t;
			while (tmp[i].label != -1)
			{
				if (tmp[i].next != 0)
					i = tmp[i].next;
				else
				{
					if (k == -1)
					{
						tmp[i].next = NTS;
						i = NTS;
					}
					else
					{
						tmp[i].next = k;
						i = k;
						int Nt = t[0].next;
						t[0].ind_TL = t[Nt].ind_TL;
						t[0].next = t[Nt].next;
						fl = 1;
					}
				}
			}
			if (fl == 0)
			{
				tmp[i].ind_TL = NTS;
				NTS++;
			}
			else
			{
				tmp[i].ind_TL = k;
			}
			tmp[i].label = key;
			tmp[i].next = 0;
		}
	}
	void remove_el(int key)
	{
		int i = Hash_function(key);
		if (t[i].label == key)
		{
			if (t[0].ind_TL == -1)
			{
				t[0].ind_TL = t[i].ind_TL;
				t[0].next = 0;
			}
			else
			{
				int g = t[0].next;
				while (t[g].ind_TL != -1)
				{
					g = t[g].next;
				}
				t[g].ind_TL = t[i].ind_TL;
			}
			if(t[i].next != 0)
			{
				int g = t[i].next;
				while (t[i].next != 0)
				{
					t[i].label = t[g].label;
					t[i].ind_TL = t[g].ind_TL;
					t[i].next = t[g].next;
					i = t[g].ind_TL;
					g = t[g].next;
				}
			}
			t[i].label = t[i].ind_TL = -1;
		}
		else
		{
			int g = t[i].next;
			//g элемент, который удаляем
			//i предыдущий
			while (t[g].label != key)
			{
				i = t[i].next;
				g = t[g].next;
			}
			int Nt = t[0].next;
			if (t[0].ind_TL == -1)
			{
				t[0].ind_TL = t[g].ind_TL;
				t[0].next = 0;
				t[Nt].label = -1;
				t[Nt].ind_TL = -1;
			}
			else
			{
				int g = t[0].next;
				while (t[g].ind_TL != -1)
				{
					g = t[g].next;
				}
				t[g].ind_TL = t[i].ind_TL;
			}
			if (t[g].next == 0)
			{
				t[g].label = -1;
				t[g].ind_TL = -1;
			}
			else
			{
				t[i].next = t[g].next;
			}
		}
	}
	void print_Hash()
	{
		int i = 0;
		while (i < 11)
		{
			if (t[i].label != -1)
			{
				int g = i;
				int fl = 1;
				while (fl)
				{
					if (t[g].next != 0)
					{
						cout << "(" << t[g].label << "," << t[g].ind_TL << ")" << "->";
						g = t[g].next;
					}
					else
					{
						cout << "(" << t[g].label << "," << t[g].ind_TL << ")" << endl;
						fl = 0;
						i++;
					}
				}
				fl = 1;
			}
			else
				i++;
		}
	}

int main()
{
	Hash table;
	table.add_el(21);
	table.add_el(121);
	table.add_el(221);
	table.add_el(1);
	table.add_el(882);
	table.add_el(522);
	table.add_el(499);
	table.add_el(341);
	table.add_el(433);
	table.print_Hash();
}
